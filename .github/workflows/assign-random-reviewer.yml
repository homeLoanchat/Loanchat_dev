name: Assign random reviewer

on:
  pull_request_target:
    types: [opened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  REVIEWER_POOL: |
    juncity-kim
    jaeaeee
    doublejh0501
    zneda330
  REVIEWER_COUNT: "1"

jobs:
  roulette:
    runs-on: ubuntu-latest
    steps:
      - name: Pick random reviewer & request review
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            try {
              const pr = context.payload.pull_request;
              if (!pr || pr.draft) {
                core.notice("Draft PR or no PR payload â€“ skipping.");
                return;
              }

              // í›„ë³´ í’€
              const pool = (process.env.REVIEWER_POOL || "")
                .split("\n").map(s => s.trim()).filter(Boolean);

              // ì‘ì„±ì/ì´ë¯¸ ìš”ì²­ëœ ë¦¬ë·°ì–´ ì œì™¸
              const author = pr.user.login.toLowerCase();
              const already = (pr.requested_reviewers || []).map(u => u.login.toLowerCase());
              let candidates = pool
                .map(u => u.trim())
                .filter(Boolean)
                .filter(u => u.toLowerCase() !== author)
                .filter(u => !already.includes(u.toLowerCase()));

              if (candidates.length === 0) {
                core.notice("No available reviewers after excluding author/already-requested.");
                return;
              }

              // ëœë¤ ì…”í”Œ
              for (let i = candidates.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
              }
              const need = Math.min(parseInt(process.env.REVIEWER_COUNT || "1", 10), candidates.length);
              const chosen = candidates.slice(0, need);

              // ë¦¬ë·° ìš”ì²­
              await github.rest.pulls.requestReviewers({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number,
                reviewers: chosen,
              });

              // ì½”ë©˜íŠ¸
              const body = `@${chosen.join(", @")} ë‹˜, ëœë¤ ë¦¬ë·° ë¯¸ì…˜ì´ ë„ì°©í–ˆìŠµë‹ˆë‹¤! ğŸš€\n\nì‘ì„±ì: @${pr.user.login}`;
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                body,
              });

              core.notice(`Requested review from: ${chosen.join(", ")}`);
            } catch (error) {
              // ì—ëŸ¬ ì›ì¸ì„ ìŠ¬ë™/ì•¡ì…˜ ë¡œê·¸ì—ì„œ ë°”ë¡œ ë³¼ ìˆ˜ ìˆê²Œ
              core.error(`Failed to assign reviewer: ${error.message}`);
              if (error.response && error.response.data) {
                core.error(`GitHub API response: ${JSON.stringify(error.response.data)}`);
              }
              core.setFailed(error.message);
            }

            